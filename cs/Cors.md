### **CORS (Cross-Origin Resource Sharing)**

- <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">관련 문서</a>
- <a href="https://clelab.io/course/developer-interview/cors%EB%9E%80">관련 문서</a>

### **CORS가 뭘까요?**

- 인터넷 환경에서 보안은 굉장히 중요하다. 많은 사람들의 정보가 들어가 있는 공간이기 때문이다. 따라서 보안에 대해 신경쓰지 않으면 나쁜마음을 먹은 누군가는 사람들의 정보를 도용해 이익을 챙길 수도 있다.
- 따라서 CORS란 `브라우저와 서버간 통신`에서 `이상한 서버와 통신`을 해서 `원하지 않은 리소스`를 받지 않도록 `방어해주는 브라우저의 보안 규칙`

### **ORIGIN**

```
https://www.jihong.com/users?sort=asc&page=1#foo
```

- 위의 URL은 `프로토콜`, `호스트`, `패스`, `쿼리스트링`, `프라그먼트`의 5가지로 이루어져 있다.

- 이때 출처는 `Protocol`과 `Host`, `:80, :443과 같은 포트 번호`까지 모두 합친 것을 의미한다.

- 출처에서 포트번호는 생략이 가능하고 이는 `HTTP`, `HTTPS`의 기본 포트번호가 정해져 있기 때문에 가능한 부분이다.

### **CORS의 기본적인 동작방식**

- 웹 클라이언트 어플리케이션이 다른 출처의 리소스를 요청할 때는 HTTP 프로토콜을 사용하여 요청을 보낸다.

- 이때 브라우저는 요청의 헤더부분에 Origin이라는 필드에 요청을 보내는 출처를 함께 담아 보냄.

- 이후 서버가 이 요청에 대한 응답하는 과정에서 응답 헤더에 `Access-Control-Allow-Origin`이라는 값에 "이 리소스를 접근하는 것이 허용된 출처"를 내려준다.

- 응답을 받은 브라우저는 자신이 보냈던 요청과 서버가 보내준 `ACAO`를 비교해본 후 응답이 유효한지 결정

### **Preflight Request**

- 일반적으로 웹 어플리케이션 개발에서 많이 마주치는 시나리오.

- 이 상황에서 브라우저는 예비 요청과 본 요청으로 나누어 전송

- 이 예비 요청에는 HTTP 메서드에서 `OPTIONS` 메서드가 사용

- 예비 요청의 역할은 본 요청을 보내기 전 브라우저가 스스로 요청을 보내는 것에 대해 안전한지 확인

<img src="../public/image/cors_flow.png">

- 브라우저에게 리소스를 받아오라는 명령을 내린다.
- 브라우저는 서버에게 예비 요청을 먼저 보낸다.
- 서버는 이 예비 요청에 대한 응답으로 현재 자신이 어떤 것들을 허용하고, 어떤 것들을 금지하고 있는지에 대한 정보를 응답 헤더에 담아서 브라우저에게 다시 보내준다.
- 브라우저는 자신이 보낸 예비 요청과 서버가 응답에 담아준 허용 정책을 비교 한다.
- 이 요청을 보내는 것이 안전하다고 판단되면 같은 엔드포인트로 다시 본 요청을 보내게 된다.
- 이후 서버가 이 본 요청에 대한 응답을 하면 브라우저는 최종적으로 이 응답 데이터를 자바스크립트에게 넘겨준다.

> CORS 정책 위반으로 인한 에러는 예비 요청의 성공 여부와 별 상관이 없다.
>
> 브라우저가 CORS 정책 위반 여부를 판단하는 시점은 예비 요청에 대한 응답을 받은 이후이기 때문이다.

### **Simple Request**

- 단순 요청은 예비 요청을 보내지 않고 바로 서버에게 본 요청부터 진행 한 후, 서버가 이에 대한 응답의 헤더에 `ACAO` 과 같은 값을 보내주면 그때 브라우저가 CORS 정책 위반 여부를 검사하는 방식이다.

- 아무때나 단순요청을 할 수 있는 것은 아님
  - 요청의 메서드 `GET`, `HEAD`, `POST` 중 하나
  - 요구하는 헤더를 만족
  - 헤더가 Content-Type일때는 `application/x-www-form-urlencoded`, `multipart/form-data`, `text/plain`만 허용

### **Credentialed Request**

- 인증된 요청을 사용하는 방법
- 기본적으로 브라우저가 제공하는 비동기 리소스 요청 API인 `XMLHttpRequest 객체`나 `fetch API`는 별도의 옵션 없이 브라우저의 쿠키 정보나 인증과 관련된 헤더를 함부로 요청에 담지 않는다.
- 이때 요청에 인증과 관련된 정보를 담을 수 있게 해주는 옵션이 바로 credentials 옵션이다.

- 이 옵션에는 총 3가지의 값을 사용할 수 있으며, 각 값들이 가지는 의미는 다음과 같다.

  - same-origin : 같은 출처 간 요청에만 인증 정보를 담을 수 있다.

  - include : 모든 요청에 인증 정보를 담는다.

    - `Access-Control-Allow-Origin`에는 `*`를 사용할 수 없으며, 명시적인 URL이어야한다.
    - 응답 헤더에는 반드시 `Access-Control-Allow-Credentials: true`가 존재해야한다.

  - omit : 모든 요청에 인증 정보를 담지 않는다.

### **CORS를 해결할 수 있는 방법**

- **Access-Control-Allow-Origin 세팅**

  - Access-Control-Allow-Origin 헤더에 알맞은 값을 세팅
  - 와일드 카드인 `*` 은 모든 출처에서 오는 요청을 받아 먹겠다는 의미기 때문에 보안적으로 심각한 이슈가 발생할 수 있음

- **Webpack Dev Server에서 제공하는 프록시 기능을 사용**

```js
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'https://api.jihong.com',
        changeOrigin: true,
        pathRewrite: { '^/api': '' },
      },
    },
  },
};
```

- 로컬 환경에서 `/api`로 시작하는 URL로 보내는 요청에 대해 브라우저는 `localhost:8000/api`로 요청을 보낸 것으로 알고 있지만, 사실 뒤에서 웹팩이 `https://api.jihong.com`으로 요청을 프록싱해주기 때문에 마치 CORS 정책을 지킨 것처럼 브라우저를 속이면서도 우리는 원하는 서버와 자유롭게 통신을 할 수 있다. 즉, `프록싱을 통해 CORS 정책을 우회할 수 있는 것`

- 이 부분은 하지만 개발모드에서는 잘 작동하지만 실제 프로덕션에서는 제대로 동작 하지 않는다.
